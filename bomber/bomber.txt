------- FILE bomber.asm LEVEL 1 PASS 2
      1  fffe					      processor	6502
      2  10000 ????
      3  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      4  10000 ????						;; Include required files with VCS register memory mapping and macros
      5  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????						;-------------------------------------------------------------------------------
     45  10000 ????						; TIA_BASE_ADDRESS
     46  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     47  10000 ????						; Normally 0, the base address should (externally, before including this file)
     48  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     49  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     50  10000 ????						; < $40 as a bankswitch.
     51  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     52  10000 ????			   -TIA_BASE_ADDRESS =	0
     53  10000 ????				       ENDIF
     54  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     55  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     56  10000 ????						; *OR* by declaring the label before including this file, eg:
     57  10000 ????						; TIA_BASE_ADDRESS = $40
     58  10000 ????						;   include "vcs.h"
     59  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     60  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     61  10000 ????						; for the mirrored ROM hardware registers.
     62  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     63  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     64  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     65  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     66  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     67  10000 ????				       ENDIF
     68  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     69  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     70  10000 ????				       ENDIF
     71  10000 ????						;-------------------------------------------------------------------------------
     72 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     73 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     74 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     75 U0000
     76 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     77 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     78 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     79 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     80 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     81 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     82 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     83 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     84 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     85 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     86 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     87 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     88 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     89 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     90 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     91 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
     92 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
     93 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
     94 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
     95 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
     96 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
     97 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
     98 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
     99 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    100 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    101 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    102 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    103 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    104 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    105 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    106 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    107 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    108 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    109 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    110 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    111 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    112 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    113 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    114 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    115 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    116 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    117 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    118 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    119 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    120 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    121 U002d
    122 U002d							;-------------------------------------------------------------------------------
    123 U000e ????				      SEG.U	TIA_REGISTERS_READ
    124 U0000					      ORG	TIA_BASE_READ_ADDRESS
    125 U0000							;											bit 7	 bit 6
    126 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    127 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    128 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    129 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    130 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    131 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    132 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    133 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    134 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    135 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    136 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    137 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    138 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    139 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    140 U000e							;-------------------------------------------------------------------------------
    141 U0298 ????				      SEG.U	RIOT
    142 U0280					      ORG	$280
    143 U0280
    144 U0280							; RIOT MEMORY MAP
    145 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    146 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    147 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    148 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    149 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    150 U0284		       00	   INTIM      ds	1	; $284		Timer output
    151 U0285		       00	   TIMINT     ds	1	; $285
    152 U0286							; Unused/undefined registers ($285-$294)
    153 U0286		       00		      ds	1	; $286
    154 U0287		       00		      ds	1	; $287
    155 U0288		       00		      ds	1	; $288
    156 U0289		       00		      ds	1	; $289
    157 U028a		       00		      ds	1	; $28A
    158 U028b		       00		      ds	1	; $28B
    159 U028c		       00		      ds	1	; $28C
    160 U028d		       00		      ds	1	; $28D
    161 U028e		       00		      ds	1	; $28E
    162 U028f		       00		      ds	1	; $28F
    163 U0290		       00		      ds	1	; $290
    164 U0291		       00		      ds	1	; $291
    165 U0292		       00		      ds	1	; $292
    166 U0293		       00		      ds	1	; $293
    167 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    168 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    169 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    170 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    171 U0298							;-------------------------------------------------------------------------------
    172 U0298							; The following required for back-compatibility with code which does not use
    173 U0298							; segments.
    174  0000 ????				      SEG
    175  0000 ????						; EOF
------- FILE bomber.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   .FREE_BYTES SET	0
    151  0000 ????				      MAC	boundary
    152  0000 ????				      REPEAT	256
    153  0000 ????				      IF	<. % {1} = 0
    154  0000 ????				      MEXIT
    155  0000 ????				      ELSE
    156  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    157  0000 ????				      .byte	$00
    158  0000 ????				      ENDIF
    159  0000 ????				      REPEND
    160  0000 ????				      ENDM
    161  0000 ????
    162  0000 ????
    163  0000 ????						; EOF
------- FILE bomber.asm
      8  0000 ????
      9  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     10  0000 ????						;; Declare the variables starting from memory address $80
     11  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     12 U009a ????				      seg.u	Variables
     13 U0080					      org	$80
     14 U0080
     15 U0080		       00	   JetXPos    byte.b		; player-0 X position
     16 U0081		       00	   JetYPos    byte.b		; Player-0 Y position
     17 U0082		       00	   BomberXPos byte.b		; Player-1 X position
     18 U0083		       00	   BomberYPos byte.b		; Player-1 Y position
     19 U0084		       00	   MissileXPos byte.b		; missile X position
     20 U0085		       00	   MissileYPos byte.b		; missile Y position
     21 U0086		       00	   Score      byte.b		; 2-digit Score stored as BCD and Timer put next to each other in memory
     22 U0087		       00	   Timer      byte.b		; 2-digit Timer stored as BCD right after score in memory so can use +/- 1
     23 U0088		       00	   Temp       byte.b		; variable to store temp score
     24 U0089		       00 00	   OnesDigitOffset word.w		; lookup table offset for the score 1's digit
     25 U008b		       00 00	   TensDigitOffset word.w		; lookup table offset for the score 10's digit
     26 U008d		       00 00	   JetSpritePtr word.w		; pointer to player 0 sprite lookup table
     27 U008f		       00 00	   JetColorPtr word.w		;
     28 U0091		       00 00	   BomberSpritePtr word.w		; pointer to player1 sprite lookup table
     29 U0093		       00 00	   BomberColorPtr word.w
     30 U0095		       00	   JetAnimeOffset byte.b		; player0 sprite frame offset for change of bitmap
     31 U0096		       00	   Random     byte.b		; random number generator
     32 U0097		       00	   ScoreSprite byte.b		; store bit pattern for score
     33 U0098		       00	   TimerSprite byte.b		; store bit patter for Timer
     34 U0099		       00	   BomberAnimeOff byte.b		; player 1 animation
     35 U009a
     36 U009a							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     37 U009a							;; Define constants
     38 U009a							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     39 U009a		       00 09	   JET_HEIGHT =	9	; number of rows in lookup table
     40 U009a		       00 09	   BOMBER_HEIGHT =	9
     41 U009a		       00 05	   DIGITS_HEIGHT =	5	;Scoreboard lookup rows
     42 U009a
     43 U009a							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     44 U009a							;; Start our ROM code at memory address $F000
     45 U009a							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     46  10000 ????				       seg	code
     47  f000					      org	$F000
     48  f000
     49  f000				   Reset
      0  f000					      CLEAN_START		; call macro to clean memory space
      1  f000		       78		      sei
      2  f001		       d8		      cld
      3  f002
      4  f002		       a2 00		      ldx	#0
      5  f004		       8a		      txa
      6  f005		       a8		      tay
      7  f006		       ca	   .CLEAR_STACK dex
      8  f007		       9a		      txs
      9  f008		       48		      pha
     10  f009		       d0 fb		      bne	.CLEAR_STACK
     11  f00b
     51  f00b
     52  f00b							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     53  f00b							;; Initialise RAM variables and TIA registers
     54  f00b							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     55  f00b		       a9 44		      lda	#68
     56  f00d		       85 80		      sta	JetXPos	; Jet X position == 68
     57  f00f		       a9 0a		      lda	#10
     58  f011		       85 81		      sta	JetYPos	; Jet X position == 10
     59  f013		       a9 36		      lda	#54
     60  f015		       85 82		      sta	BomberXPos	; bomber X
     61  f017		       a9 53		      lda	#83
     62  f019		       85 83		      sta	BomberYPos	; Bomber Y
     63  f01b		       a9 00		      lda	#0
     64  f01d		       85 95		      sta	JetAnimeOffset	; JetAnimeOffset = 0
     65  f01f		       a9 00		      lda	#0
     66  f021		       85 99		      sta	BomberAnimeOff	; = 0
     67  f023		       a9 d4		      lda	#%11010100
     68  f025		       85 96		      sta	Random	; Random = $D4
     69  f027		       a9 00		      lda	#0
     70  f029		       85 86		      sta	Score	; initialise to 0
     71  f02b		       85 87		      sta	Timer	; initialise to 0
     72  f02d
     73  f02d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     74  f02d							;; Declare MACRO to check if we should render the missile
     75  f02d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     76  f02d					      MAC	draw_missile
     77  f02d					      lda	#0	; start accumualtor with 0 (null position)
     78  f02d					      cpx	MissileYPos	; compare X/scanline with missile y-position
     79  f02d					      bne	.SkipMissileDraw	; if is not equal, skip the draw of missile0
     80  f02d					      inc	MissileYPos	; else, increase y-position of the bullet/ball
     81  f02d					      lda	#%00000010	; and set ENAM0 second bit to enable missile
     82  f02d				   .SkipMissileDraw
     83  f02d					      sta	ENAM0	; store correct value in the TIA missile register
     84  f02d					      lda	#$0E	; set scoreboard color whiteish
     85  f02d					      sta	COLUP0
     86  f02d					      ENDM
     87  f02d
     88  f02d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     89  f02d							;; Initialise the pointers to the correct lookup table
     90  f02d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     91  f02d		       a9 53		      lda	#<JetSprite
     92  f02f		       85 8d		      sta	JetSpritePtr	; lo-byte pointer for jet sprite  lookup table
     93  f031		       a9 f3		      lda	#>JetSprite
     94  f033		       85 8e		      sta	JetSpritePtr+1	; hi-byte
     95  f035
     96  f035		       a9 de		      lda	#<JetColor
     97  f037		       85 8f		      sta	JetColorPtr	; lo-byte
     98  f039		       a9 f3		      lda	#>JetColor
     99  f03b		       85 90		      sta	JetColorPtr+1	; hi-byte
    100  f03d
    101  f03d		       a9 65		      lda	#<BomberSprite
    102  f03f		       85 91		      sta	BomberSpritePtr	; lo-byte
    103  f041		       a9 f3		      lda	#>BomberSprite
    104  f043		       85 92		      sta	BomberSpritePtr+1	; hi-byte
    105  f045
    106  f045		       a9 f0		      lda	#<BomberColor
    107  f047		       85 93		      sta	BomberColorPtr	; lo-byte
    108  f049		       a9 f3		      lda	#>BomberColor
    109  f04b		       85 94		      sta	BomberColorPtr+1	; hi-byte
    110  f04d
    111  f04d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    112  f04d							;; Start the main display loop and frame rendering
    113  f04d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    114  f04d				   StartFrame
    115  f04d
    116  f04d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    117  f04d							;; Display 3 VSYNC
    118  f04d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    119  f04d		       a9 02		      lda	#2
    120  f04f		       85 01		      sta	VBLANK
    121  f051		       85 00		      sta	VSYNC
    122  f053					      REPEAT	3
    123  f053		       85 02		      sta	WSYNC	; displays the 3 lines of VSYNC
    122  f053					      REPEND
    123  f055		       85 02		      sta	WSYNC	; displays the 3 lines of VSYNC
    122  f055					      REPEND
    123  f057		       85 02		      sta	WSYNC	; displays the 3 lines of VSYNC
    124  f059					      REPEND
    125  f059		       a9 00		      lda	#0
    126  f05b		       85 00		      sta	VSYNC	; turn off VSYNC
    127  f05d
    128  f05d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    129  f05d							;; Calculations and tasks performed in pre-VBLANK
    130  f05d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    131  f05d		       a5 80		      lda	JetXPos
    132  f05f		       a0 00		      ldy	#0
    133  f061		       20 78 f2 	      jsr	SetObjectXPos	; set player 0 horizontal position
    134  f064
    135  f064		       a5 82		      lda	BomberXPos
    136  f066		       a0 01		      ldy	#1
    137  f068		       20 78 f2 	      jsr	SetObjectXPos	; set player 1 horizontal position
    138  f06b
    139  f06b		       a5 84		      lda	MissileXPos
    140  f06d		       a0 02		      ldy	#2
    141  f06f		       20 78 f2 	      jsr	SetObjectXPos	; set missile horizontal position
    142  f072
    143  f072		       20 b5 f2 	      jsr	CalculateDigitOffset	; calculate the scoreboard digit lookup table offset
    144  f075
    145  f075		       20 61 f2 	      jsr	GenerateJetSound	; call audio routine
    146  f078
    147  f078		       85 02		      sta	WSYNC
    148  f07a		       85 2a		      sta	HMOVE	; apply the horizontal offsets
    149  f07c
    150  f07c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    151  f07c							;; Display remaining lines of VBLANK
    152  f07c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    153  f07c					      REPEAT	34
    154  f07c		       85 02		      sta	WSYNC
    153  f07c					      REPEND
    154  f07e		       85 02		      sta	WSYNC
    153  f07e					      REPEND
    154  f080		       85 02		      sta	WSYNC
    153  f080					      REPEND
    154  f082		       85 02		      sta	WSYNC
    153  f082					      REPEND
    154  f084		       85 02		      sta	WSYNC
    153  f084					      REPEND
    154  f086		       85 02		      sta	WSYNC
    153  f086					      REPEND
    154  f088		       85 02		      sta	WSYNC
    153  f088					      REPEND
    154  f08a		       85 02		      sta	WSYNC
    153  f08a					      REPEND
    154  f08c		       85 02		      sta	WSYNC
    153  f08c					      REPEND
    154  f08e		       85 02		      sta	WSYNC
    153  f08e					      REPEND
    154  f090		       85 02		      sta	WSYNC
    153  f090					      REPEND
    154  f092		       85 02		      sta	WSYNC
    153  f092					      REPEND
    154  f094		       85 02		      sta	WSYNC
    153  f094					      REPEND
    154  f096		       85 02		      sta	WSYNC
    153  f096					      REPEND
    154  f098		       85 02		      sta	WSYNC
    153  f098					      REPEND
    154  f09a		       85 02		      sta	WSYNC
    153  f09a					      REPEND
    154  f09c		       85 02		      sta	WSYNC
    153  f09c					      REPEND
    154  f09e		       85 02		      sta	WSYNC
    153  f09e					      REPEND
    154  f0a0		       85 02		      sta	WSYNC
    153  f0a0					      REPEND
    154  f0a2		       85 02		      sta	WSYNC
    153  f0a2					      REPEND
    154  f0a4		       85 02		      sta	WSYNC
    153  f0a4					      REPEND
    154  f0a6		       85 02		      sta	WSYNC
    153  f0a6					      REPEND
    154  f0a8		       85 02		      sta	WSYNC
    153  f0a8					      REPEND
    154  f0aa		       85 02		      sta	WSYNC
    153  f0aa					      REPEND
    154  f0ac		       85 02		      sta	WSYNC
    153  f0ac					      REPEND
    154  f0ae		       85 02		      sta	WSYNC
    153  f0ae					      REPEND
    154  f0b0		       85 02		      sta	WSYNC
    153  f0b0					      REPEND
    154  f0b2		       85 02		      sta	WSYNC
    153  f0b2					      REPEND
    154  f0b4		       85 02		      sta	WSYNC
    153  f0b4					      REPEND
    154  f0b6		       85 02		      sta	WSYNC
    153  f0b6					      REPEND
    154  f0b8		       85 02		      sta	WSYNC
    153  f0b8					      REPEND
    154  f0ba		       85 02		      sta	WSYNC
    153  f0ba					      REPEND
    154  f0bc		       85 02		      sta	WSYNC
    153  f0bc					      REPEND
    154  f0be		       85 02		      sta	WSYNC
    155  f0c0					      REPEND
    156  f0c0		       a9 00		      lda	#0
    157  f0c2		       85 01		      sta	VBLANK	; turn off VBLANK
    158  f0c4
    159  f0c4							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    160  f0c4							;; Display the scoreboard lines
    161  f0c4							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    162  f0c4				   ScoreBoardVisibleLines
    163  f0c4		       a9 00		      lda	#0	; clear TIA registers
    164  f0c6		       85 0d		      sta	PF0
    165  f0c8		       85 0e		      sta	PF1
    166  f0ca		       85 0f		      sta	PF2
    167  f0cc		       85 1b		      sta	GRP0
    168  f0ce		       85 1c		      sta	GRP1
    169  f0d0		       a9 0e		      lda	#$0E	; set scoreboard color whiteish
    170  f0d2		       85 08		      sta	COLUPF
    171  f0d4		       a9 00		      lda	#%00000000
    172  f0d6		       85 0a		      sta	CTRLPF
    173  f0d8
    174  f0d8		       a2 05		      ldx	#DIGITS_HEIGHT	; start X counter with 5 (height of digits)
    175  f0da
    176  f0da				   .ScoreDigitLoop
    177  f0da		       a4 8b		      ldy	TensDigitOffset	; get the Tensdigitoffset for score
    178  f0dc		       b9 d6 f2 	      lda	Digits,Y	; load the bit pattern from lookup table
    179  f0df		       29 f0		      and	#$F0	; remove the graphics for 1s digit
    180  f0e1		       85 97		      sta	ScoreSprite	; save the score Tens digit patter in variable
    181  f0e3
    182  f0e3		       a4 89		      ldy	OnesDigitOffset	; get the onesDigit
    183  f0e5		       b9 d6 f2 	      lda	Digits,Y	; load bit pattern from lookup
    184  f0e8		       29 0f		      and	#$0F	; mask the Tens using 00001111
    185  f0ea
    186  f0ea		       05 97		      ora	ScoreSprite	; merge it with saved TensDigit graphic
    187  f0ec		       85 97		      sta	ScoreSprite	; and save it
    188  f0ee
    189  f0ee		       85 02		      sta	WSYNC	; wait for the of scanline
    190  f0f0
    191  f0f0		       85 0e		      sta	PF1	; update the playfield to display score sprite
    192  f0f2		       a4 8c		      ldy	TensDigitOffset+1	; get the left digitoffset for timer
    193  f0f4		       b9 d6 f2 	      lda	Digits,Y	; load from lookup
    194  f0f7		       29 f0		      and	#$F0	; get only the Tens
    195  f0f9		       85 98		      sta	TimerSprite	; save it
    196  f0fb
    197  f0fb		       a4 8a		      ldy	OnesDigitOffset+1	; get the right digitoffet for timer
    198  f0fd		       b9 d6 f2 	      lda	Digits,y	; load digit pattern
    199  f100		       29 0f		      and	#$0F	; remove tens
    200  f102
    201  f102		       05 98		      ora	TimerSprite	; merge with saved Tens digit graphic
    202  f104		       85 98		      sta	TimerSprite	; and save it
    203  f106
    204  f106		       20 d5 f2 	      jsr	Sleep12Cycles	; waste some clock cycles
    205  f109
    206  f109		       85 0e		      sta	PF1	; update playfield for Timer Display
    207  f10b		       a4 97		      ldy	ScoreSprite	; preload for next scanline
    208  f10d		       85 02		      sta	WSYNC
    209  f10f
    210  f10f		       84 0e		      sty	PF1	; update playfield for score display
    211  f111		       e6 8b		      inc	TensDigitOffset
    212  f113		       e6 8c		      inc	TensDigitOffset+1
    213  f115		       e6 89		      inc	OnesDigitOffset
    214  f117		       e6 8a		      inc	OnesDigitOffset+1
    215  f119		       20 d5 f2 	      jsr	Sleep12Cycles	; waste some clock cycles again
    216  f11c
    217  f11c		       ca		      dex
    218  f11d		       85 0e		      sta	PF1	; update playfield for the timer
    219  f11f		       d0 b9		      bne	.ScoreDigitLoop	; if dex !=0, then branch
    220  f121
    221  f121		       85 02		      sta	WSYNC
    222  f123		       86 0e		      stx	PF1
    223  f125		       85 02		      sta	WSYNC
    224  f127
    225  f127							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    226  f127							;; Display the 96 visible scanlines of our main game (2 line kernel)
    227  f127							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    228  f127				   GasVisibleLine
    229  f127		       a9 00		      lda	#$00	; store background colour to black
    230  f129		       85 09		      sta	COLUBK
    231  f12b		       a9 02		      lda	#$02	; store playfield colour green
    232  f12d		       85 08		      sta	COLUPF
    233  f12f		       a9 01		      lda	#%000000001	; enable display playfield reflect
    234  f131		       85 0a		      sta	CTRLPF
    235  f133		       a9 f0		      lda	#$F0	; setting PF0 bit pattern
    236  f135		       85 0d		      sta	PF0
    237  f137		       a9 c0		      lda	#%11000000	; setting PF1 bit pattern
    238  f139		       85 0e		      sta	PF1
    239  f13b		       a9 00		      lda	#0	; setting PF2 bit pattern
    240  f13d		       85 0f		      sta	PF2
    241  f13f
    242  f13f		       a2 54		      ldx	#84	; (192-20/2) X counts number of remaining scanlines
    243  f141				   .GameLineLoop
      0  f141					      DRAW_MISSILE		; check if missile should be rendered
      1  f141		       a9 00		      lda	#0
      2  f143		       e4 85		      cpx	MissileYPos
      3  f145		       d0 04		      bne	.SkipMissileDraw
      4  f147		       e6 85		      inc	MissileYPos
      5  f149		       a9 02		      lda	#%00000010
      6  f14b				   .SkipMissileDraw
      7  f14b		       85 1d		      sta	ENAM0
      8  f14d		       a9 0e		      lda	#$0E
      9  f14f		       85 06		      sta	COLUP0
    245  f151
    246  f151				   .IsInsideJetSprite		; check if should render sprite player0
    247  f151		       8a		      txa		; transfer X to A
    248  f152		       38		      sec		; set carry flag as subtraction
    249  f153		       e5 81		      sbc	JetYPos	; subtract sprite Y coordinate
    250  f155		       c9 09		      cmp	#JET_HEIGHT	; compare with Jet height
    251  f157		       90 02		      bcc	.DrawJetSprite	; if result < SpriteHeight, call subroutine
    252  f159		       a9 00		      lda	#0	; else, set lookup index to 0
    253  f15b				   .DrawJetSprite
    254  f15b		       18		      clc		; clear carry flag before addition
    255  f15c		       65 95		      adc	JetAnimeOffset	; jump to correct sprite frame address in memory
    256  f15e		       a8		      tay		; load A->Y as only Y register allows indirect addressing for pointer
    257  f15f		       b1 8d		      lda	(JetSpritePtr),Y	; load player bitmap slice of data
    258  f161		       85 02		      sta	WSYNC	; wait for next scanline
    259  f163		       85 1b		      sta	GRP0	; set graphics for player 0
    260  f165		       b1 8f		      lda	(JetColorPtr),Y	; load player color from lookup table
    261  f167		       85 06		      sta	COLUP0	; set color for player 0 slice
    262  f169
    263  f169				   .IsInsideBomberSprite		; check if should render sprite player1
    264  f169		       8a		      txa		; transfer X to A
    265  f16a		       38		      sec		; set carry flag for subtraction
    266  f16b		       e5 83		      sbc	BomberYPos	; subtract sprite Y coordinate
    267  f16d		       c9 09		      cmp	#BOMBER_HEIGHT	; are we inside the sprite height bounds?
    268  f16f		       90 02		      bcc	.DrawBomberSprite	; if result < SpriteHeight, call subroutine
    269  f171		       a9 00		      lda	#0	; else, set index to 0
    270  f173				   .DrawBomberSprite
    271  f173		       18		      clc		; clear carry flag before addition
    272  f174		       65 99		      adc	BomberAnimeOff	; jump to correct sprite frame address in memory
    273  f176		       a8		      tay
    274  f177		       a9 05		      lda	#%0000101	; pattern to stretch to
    275  f179		       85 05		      sta	NUSIZ1	; stretch player1 sprite
    276  f17b		       b1 91		      lda	(BomberSpritePtr),Y	; load player bitmap slice of data
    277  f17d		       85 02		      sta	WSYNC	; wait for next scanline
    278  f17f		       85 1c		      sta	GRP1	; set graphics for player 0
    279  f181		       b1 93		      lda	(BomberColorPtr),Y	; load player color from lookup table
    280  f183		       85 07		      sta	COLUP1	; set color for player 0 slice
    281  f185
    282  f185		       ca		      dex		; X--
    283  f186		       d0 b9		      bne	.GameLineLoop	; repeat next main game scanline until finished
    284  f188
    285  f188		       a9 00		      lda	#0
    286  f18a		       85 95		      sta	JetAnimeOffset	; reset jet animation frame to zero
    287  f18c		       a9 00		      lda	#0
    288  f18e		       85 99		      sta	BomberAnimeOff	; reset jet animation frame to zero
    289  f190
    290  f190		       85 02		      sta	WSYNC	; wait for next scanline
    291  f192
    292  f192							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    293  f192							;; Display overscan
    294  f192							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    295  f192		       a9 02		      lda	#2	; initialise VBLANK
    296  f194		       85 01		      sta	VBLANK
    297  f196					      REPEAT	30
    298  f196		       85 02		      sta	WSYNC
    297  f196					      REPEND
    298  f198		       85 02		      sta	WSYNC
    297  f198					      REPEND
    298  f19a		       85 02		      sta	WSYNC
    297  f19a					      REPEND
    298  f19c		       85 02		      sta	WSYNC
    297  f19c					      REPEND
    298  f19e		       85 02		      sta	WSYNC
    297  f19e					      REPEND
    298  f1a0		       85 02		      sta	WSYNC
    297  f1a0					      REPEND
    298  f1a2		       85 02		      sta	WSYNC
    297  f1a2					      REPEND
    298  f1a4		       85 02		      sta	WSYNC
    297  f1a4					      REPEND
    298  f1a6		       85 02		      sta	WSYNC
    297  f1a6					      REPEND
    298  f1a8		       85 02		      sta	WSYNC
    297  f1a8					      REPEND
    298  f1aa		       85 02		      sta	WSYNC
    297  f1aa					      REPEND
    298  f1ac		       85 02		      sta	WSYNC
    297  f1ac					      REPEND
    298  f1ae		       85 02		      sta	WSYNC
    297  f1ae					      REPEND
    298  f1b0		       85 02		      sta	WSYNC
    297  f1b0					      REPEND
    298  f1b2		       85 02		      sta	WSYNC
    297  f1b2					      REPEND
    298  f1b4		       85 02		      sta	WSYNC
    297  f1b4					      REPEND
    298  f1b6		       85 02		      sta	WSYNC
    297  f1b6					      REPEND
    298  f1b8		       85 02		      sta	WSYNC
    297  f1b8					      REPEND
    298  f1ba		       85 02		      sta	WSYNC
    297  f1ba					      REPEND
    298  f1bc		       85 02		      sta	WSYNC
    297  f1bc					      REPEND
    298  f1be		       85 02		      sta	WSYNC
    297  f1be					      REPEND
    298  f1c0		       85 02		      sta	WSYNC
    297  f1c0					      REPEND
    298  f1c2		       85 02		      sta	WSYNC
    297  f1c2					      REPEND
    298  f1c4		       85 02		      sta	WSYNC
    297  f1c4					      REPEND
    298  f1c6		       85 02		      sta	WSYNC
    297  f1c6					      REPEND
    298  f1c8		       85 02		      sta	WSYNC
    297  f1c8					      REPEND
    298  f1ca		       85 02		      sta	WSYNC
    297  f1ca					      REPEND
    298  f1cc		       85 02		      sta	WSYNC
    297  f1cc					      REPEND
    298  f1ce		       85 02		      sta	WSYNC
    297  f1ce					      REPEND
    298  f1d0		       85 02		      sta	WSYNC
    299  f1d2					      REPEND
    300  f1d2		       a9 00		      lda	#0
    301  f1d4		       85 01		      sta	VBLANK	; turn off
    302  f1d6
    303  f1d6							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    304  f1d6							;; Process joystick input for player0
    305  f1d6							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    306  f1d6				   CheckP0Up
    307  f1d6		       a9 10		      lda	#%00010000	; player0 joystick up
    308  f1d8		       2c 80 02 	      bit	SWCHA
    309  f1db		       d0 06		      bne	CheckP0Down
    310  f1dd		       e6 81		      inc	JetYPos	; increment on Y
    311  f1df		       a9 00		      lda	#0
    312  f1e1		       85 95		      sta	JetAnimeOffset	; reset sprite frame to first frame
    313  f1e3
    314  f1e3				   CheckP0Down
    315  f1e3		       a9 20		      lda	#%00100000
    316  f1e5		       2c 80 02 	      bit	SWCHA
    317  f1e8		       d0 06		      bne	CheckP0Left
    318  f1ea		       c6 81		      dec	JetYPos
    319  f1ec		       a9 00		      lda	#0
    320  f1ee		       85 95		      sta	JetAnimeOffset	; reset sprite frame to first frame
    321  f1f0
    322  f1f0				   CheckP0Left
    323  f1f0		       a9 40		      lda	#%01000000
    324  f1f2		       2c 80 02 	      bit	SWCHA
    325  f1f5		       d0 06		      bne	CheckP0Right
    326  f1f7		       c6 80		      dec	JetXPos
    327  f1f9		       a5 09		      lda	JET_HEIGHT	; =9
    328  f1fb		       85 95		      sta	JetAnimeOffset	; set animation offset to the second frame
    329  f1fd
    330  f1fd				   CheckP0Right
    331  f1fd		       a9 80		      lda	#%10000000
    332  f1ff		       2c 80 02 	      bit	SWCHA
    333  f202		       d0 06		      bne	CheckBtnPressed
    334  f204		       e6 80		      inc	JetXPos	; increment on X
    335  f206		       a5 09		      lda	JET_HEIGHT	; =9
    336  f208		       85 95		      sta	JetAnimeOffset	; set animation offset to the second frame
    337  f20a
    338  f20a				   CheckBtnPressed
    339  f20a		       a9 80		      lda	#%10000000
    340  f20c		       24 0c		      bit	INPT4
    341  f20e		       d0 0c		      bne	NoInput
    342  f210		       a5 80		      lda	JetXPos
    343  f212		       69 04		      adc	#4
    344  f214		       85 84		      sta	MissileXPos
    345  f216		       a5 81		      lda	JetYPos
    346  f218		       69 05		      adc	#5
    347  f21a		       85 85		      sta	MissileYPos
    348  f21c
    349  f21c				   NoInput		; fall back when no input
    350  f21c
    351  f21c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    352  f21c							;; Calculations to update position for next frame
    353  f21c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    354  f21c				   UpdateBomberPosition
    355  f21c		       a5 83		      lda	BomberYPos
    356  f21e		       18		      clc
    357  f21f		       c9 00		      cmp	#0	; comparing Y pos with 0
    358  f221		       30 0e		      bmi	.ResetBomberPosition	; if < 0 reset Y to top #96
    359  f223		       c6 83		      dec	BomberYPos	; else decrement BomberYPos
    360  f225		       4c 28 f2 	      jmp	ExplosionCheck
    361  f228
    362  f228				   ExplosionCheck
    363  f228		       a9 80		      lda	#%10000000	; CXMOP bit 7 detects M0 and P1 collision
    364  f22a		       24 00		      bit	CXM0P	; check CXM0P register bit 7
    365  f22c		       d0 0a		      bne	.CollisionM0P1
    366  f22e		       4c 44 f2 	      jmp	EndPositionUpdate
    367  f231
    368  f231				   .ResetBomberPosition
    369  f231		       20 97 f2 	      jsr	GetRandomBomberPos	; call subroutine
    370  f234		       e6 86		      inc	Score	; after each enemy respawns increment score
    371  f236		       e6 87		      inc	Timer	; increment Timer
    372  f238
    373  f238				   .CollisionM0P1
    374  f238		       a5 09		      lda	BOMBER_HEIGHT	; =9
    375  f23a		       85 99		      sta	BomberAnimeOff	; set animation offset to the second frame
    376  f23c		       e6 86		      inc	Score	; after each enemy respawns increment score
    377  f23e		       e6 87		      inc	Timer	; increment Timer
    378  f240
    379  f240		       a9 00		      lda	#0
    380  f242		       85 85		      sta	MissileYPos
    381  f244
    382  f244				   EndPositionUpdate		; fall back for position update code
    383  f244
    384  f244
    385  f244							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    386  f244							;; Check collision between player0 and playfield
    387  f244							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    388  f244				   CheckCollisionP0P1
    389  f244		       a9 80		      lda	#%10000000	; CXPPMM bit 7 detects P0 and P1 collision
    390  f246		       24 07		      bit	CXPPMM	; check CXPPMM register bit 7
    391  f248		       d0 03		      bne	.CollisionP0P1	; collision between P0 and P1 happened
    392  f24a		       4c 50 f2 	      jmp	CheckCollisionP0PF
    393  f24d				   .CollisionP0P1
    394  f24d		       20 8c f2 	      jsr	GameOver	; call gameover subroutine when collision happens
    395  f250
    396  f250				   CheckCollisionP0PF
    397  f250		       a9 80		      lda	#%10000000	; CXP0FB bit 7 detects P0 and PF collision
    398  f252		       24 02		      bit	CXP0FB	; check CXP0FB register bit 7
    399  f254		       d0 03		      bne	.CollisionP0PF	; collision P0 with playfield happened
    400  f256		       4c 5c f2 	      jmp	EndCollisionCheck	; was CheckCollisionM0P1
    401  f259				   .CollisionP0PF
    402  f259		       20 8c f2 	      jsr	GameOver	; call gameover subroutine when collision happens
    403  f25c
    404  f25c
    405  f25c							;CheckCollisionM0P1:
    406  f25c							;lda #%10000000		      ; CXMOP bit 7 detects M0 and P1 collision
    407  f25c							;bit CXM0P			      ; check CXM0P register bit 7
    408  f25c							;bne .CollisionM0P1		      ; collision MO with bomber happened
    409  f25c							;    jmp EndCollisionCheck
    410  f25c							;.CollisionM0P1:
    411  f25c							;   inc Score				 ; increase score +1
    412  f25c
    413  f25c							;  lda #0
    414  f25c							; sta MissileYPos
    415  f25c
    416  f25c
    417  f25c				   EndCollisionCheck
    418  f25c		       85 2c		      sta	CXCLR	; clear all collision flags before next frame
    419  f25e
    420  f25e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    421  f25e							;; Loop back to start
    422  f25e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    423  f25e		       4c 4d f0 	      jmp	StartFrame
    424  f261
    425  f261							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    426  f261							;; Produce audio for the jet sound based on jet y-position
    427  f261							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    428  f261							;; The frequency will be modified based on the jet y-position.
    429  f261							;; Normally, the TIA audio frequency goes from 0=highest to 31=lowest.
    430  f261							;; We start from frequency 25 and then subtract the result of (JetYPos / 8)
    431  f261							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    432  f261				   GenerateJetSound subroutine
    433  f261		       a5 81		      lda	JetYPos	; load accumulator with jet y-position
    434  f263		       4a		      lsr
    435  f264		       4a		      lsr
    436  f265		       4a		      lsr		; divide accumulator by 8 with 3 right shifts
    437  f266		       85 88		      sta	Temp
    438  f268		       a9 19		      lda	#25	; frequency will be #25 minus the y-pos offset
    439  f26a		       38		      sec
    440  f26b		       e5 88		      sbc	Temp	; subtract the y-position offset saved in Temp
    441  f26d		       85 17		      sta	AUDF0	; set the new audio frequency register
    442  f26f
    443  f26f		       a9 01		      lda	#1	; sets the audio volume
    444  f271		       85 19		      sta	AUDV0
    445  f273		       a9 03		      lda	#3	; sets the audio control register distortion
    446  f275		       85 15		      sta	AUDC0
    447  f277		       60		      rts
    448  f278
    449  f278							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    450  f278							;; Subroutine to hanlde object Horizontal position with fine offset
    451  f278							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    452  f278							;; A it the target X-coordinate position in pixels of our object
    453  f278							;; Y is the object type (0:player0, 1:player1, 2:missile0, 3:missile1, 4:ball)
    454  f278							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    455  f278				   SetObjectXPos subroutine
    456  f278		       85 02		      sta	WSYNC
    457  f27a		       38		      Sec
    458  f27b				   .Div15Loop		; . means local, only can be called in subroutine
    459  f27b		       e9 0f		      sbc	#15
    460  f27d		       b0 fc		      bcs	.Div15Loop
    461  f27f		       49 07		      eor	#7
    462  f281		       0a		      asl
    463  f282		       0a		      asl
    464  f283		       0a		      asl
    465  f284		       0a		      asl		; shift left 4 times as HMP0 works with top 4 bits
    466  f285		       99 20 00 	      sta	HMP0,Y	; adding Y to the address to offset registers, ie HMP1 is next to HMP0
    467  f288		       99 10 00 	      sta	RESP0,Y	; reset player0 + Y
    468  f28b
    469  f28b		       60		      rts		; return subroutine, go back to caller
    470  f28c
    471  f28c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    472  f28c							;; Game over Subroutine
    473  f28c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    474  f28c				   GameOver   subroutine
    475  f28c		       a9 30		      lda	#$30
    476  f28e		       85 09		      sta	COLUBK
    477  f290		       85 08		      sta	COLUPF	; set playfield color to red
    478  f292
    479  f292		       a9 00		      lda	#0
    480  f294		       85 86		      sta	Score	; score = 0 at game over
    481  f296		       60		      rts
    482  f297
    483  f297							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    484  f297							;; Subroutine to generate LFSR random number
    485  f297							;; Generaye a LFSR random number
    486  f297							;; Divide random number by 4 to limit the size of the result
    487  f297							;; Add 30 to compensate for left playfield
    488  f297							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    489  f297				   GetRandomBomberPos subroutine
    490  f297		       a5 96		      lda	Random
    491  f299		       0a		      asl
    492  f29a		       45 96		      eor	Random
    493  f29c		       0a		      asl
    494  f29d		       45 96		      eor	Random
    495  f29f		       0a		      asl
    496  f2a0		       0a		      asl
    497  f2a1		       45 96		      eor	Random
    498  f2a3		       0a		      asl
    499  f2a4		       26 96		      rol	Random
    500  f2a6
    501  f2a6		       4a		      lsr
    502  f2a7		       4a		      lsr		; divide the value by 4 with 2 right shifts
    503  f2a8		       85 82		      sta	BomberXPos	; save to variable BomberXPos
    504  f2aa		       a9 1e		      lda	#30
    505  f2ac		       65 82		      adc	BomberXPos	; adds 30 + BomberXPos in accumulator
    506  f2ae		       85 82		      sta	BomberXPos	; and sets position
    507  f2b0
    508  f2b0		       a9 60		      lda	#96
    509  f2b2		       85 83		      sta	BomberYPos	; set the y position to the top of the screen
    510  f2b4
    511  f2b4		       60		      rts
    512  f2b5
    513  f2b5							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    514  f2b5							;; Subroutine to handle scoreboard digits to be displayed on the screen
    515  f2b5							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    516  f2b5							;; The scoreboard is stored using BCD, so the display shows hex numbers.
    517  f2b5							;; Each digit has a height of 5 bytes in lookup
    518  f2b5							;; convert high and low nibbles of the variable score and timer
    519  f2b5							;; inthe the offsets of digits lookup table so the valus can be displayed
    520  f2b5							;; for the low nibble we need to multiply by 5
    521  f2b5							;;  - we can use left shifts to perform multiplication by 2
    522  f2b5							;;  - for any number N, the value of N*5 = (N*2*2)+N
    523  f2b5							;;
    524  f2b5							;;  For the upper nibbles, since it's already times 11, we need to divide it
    525  f2b5							;; and then multiply by 5:
    526  f2b5							;; - we can use right shifts to perform dividion by 2
    527  f2b5							;; - for any number N, the value of (N/16)* 5 = (n/2/2)+(N/2/2/2/2)
    528  f2b5							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    529  f2b5				   CalculateDigitOffset subroutine
    530  f2b5		       a2 01		      ldx	#1	; x register the loop counter
    531  f2b7				   .PrepareScoreLoop		; this will loop twice, first X=1, secnond X =0
    532  f2b7
    533  f2b7		       b5 86		      lda	Score,X	; Timer loaded to A (X=1) or score (X = 0)
    534  f2b9		       29 0f		      and	#$0F	; AND to remove the first byte as 0000 will be masked
    535  f2bb		       85 88		      sta	Temp	; save the value of A into Temp
    536  f2bd		       0a		      asl		; N *2
    537  f2be		       0a		      asl		; N *4
    538  f2bf		       65 88		      adc	Temp	; add the value saved in Temp (+N)
    539  f2c1		       95 89		      sta	OnesDigitOffset,X	; storing value for Timer
    540  f2c3
    541  f2c3		       b5 86		      lda	Score,x	; load A with Timer (X=1) or Score (X=0)
    542  f2c5		       29 f0		      and	#$F0	; remove the ones digit by masking 4 bits with 11110000
    543  f2c7		       4a		      lsr		; shift right N/2
    544  f2c8		       4a		      lsr		; N/4
    545  f2c9		       85 88		      sta	Temp	; save value of A into Temp
    546  f2cb		       4a		      lsr		; N/8
    547  f2cc		       4a		      lsr		; N/16
    548  f2cd		       65 88		      adc	Temp	; add value saved in Temp (N/16+ N/4)
    549  f2cf		       95 8b		      sta	TensDigitOffset,x	; store A in TensDigitOffset+1 or TenssDigitOffset
    550  f2d1
    551  f2d1		       ca		      dex		; X--
    552  f2d2		       10 e3		      bpl	.PrepareScoreLoop	; while X >= 0 , loop to pass a second time
    553  f2d4		       60		      rts
    554  f2d5
    555  f2d5							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    556  f2d5							;; subroutine that waits for 12 cycles
    557  f2d5							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    558  f2d5							;; jsr takes 6 cycles
    559  f2d5							;; rts takes 6 cycles
    560  f2d5							;; just calling the subroutine wastes 12 cycles
    561  f2d5							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    562  f2d5				   Sleep12Cycles subroutine
    563  f2d5		       60		      rts
    564  f2d6
    565  f2d6							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    566  f2d6							;; Declare ROM Lookup tables
    567  f2d6							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    568  f2d6				   Digits
    569  f2d6		       77		      .byte.b	%01110111	; ### ###
    570  f2d7		       55		      .byte.b	%01010101	; # # # #
    571  f2d8		       55		      .byte.b	%01010101	; # # # #
    572  f2d9		       55		      .byte.b	%01010101	; # # # #
    573  f2da		       77		      .byte.b	%01110111	; ### ###
    574  f2db
    575  f2db		       11		      .byte.b	%00010001	; # #
    576  f2dc		       11		      .byte.b	%00010001	; # #
    577  f2dd		       11		      .byte.b	%00010001	; # #
    578  f2de		       11		      .byte.b	%00010001	; # #
    579  f2df		       11		      .byte.b	%00010001	; # #
    580  f2e0
    581  f2e0		       77		      .byte.b	%01110111	; ### ###
    582  f2e1		       11		      .byte.b	%00010001	; # #
    583  f2e2		       77		      .byte.b	%01110111	; ### ###
    584  f2e3		       44		      .byte.b	%01000100	; # #
    585  f2e4		       77		      .byte.b	%01110111	; ### ###
    586  f2e5
    587  f2e5		       77		      .byte.b	%01110111	; ### ###
    588  f2e6		       11		      .byte.b	%00010001	; # #
    589  f2e7		       33		      .byte.b	%00110011	; ## ##
    590  f2e8		       11		      .byte.b	%00010001	; # #
    591  f2e9		       77		      .byte.b	%01110111	; ### ###
    592  f2ea
    593  f2ea		       55		      .byte.b	%01010101	; # # # #
    594  f2eb		       55		      .byte.b	%01010101	; # # # #
    595  f2ec		       77		      .byte.b	%01110111	; ### ###
    596  f2ed		       11		      .byte.b	%00010001	; # #
    597  f2ee		       11		      .byte.b	%00010001	; # #
    598  f2ef
    599  f2ef		       77		      .byte.b	%01110111	; ### ###
    600  f2f0		       44		      .byte.b	%01000100	; # #
    601  f2f1		       77		      .byte.b	%01110111	; ### ###
    602  f2f2		       11		      .byte.b	%00010001	; # #
    603  f2f3		       77		      .byte.b	%01110111	; ### ###
    604  f2f4
    605  f2f4		       77		      .byte.b	%01110111	; ### ###
    606  f2f5		       44		      .byte.b	%01000100	; # #
    607  f2f6		       77		      .byte.b	%01110111	; ### ###
    608  f2f7		       55		      .byte.b	%01010101	; # # # #
    609  f2f8		       77		      .byte.b	%01110111	; ### ###
    610  f2f9
    611  f2f9		       77		      .byte.b	%01110111	; ### ###
    612  f2fa		       11		      .byte.b	%00010001	; # #
    613  f2fb		       11		      .byte.b	%00010001	; # #
    614  f2fc		       11		      .byte.b	%00010001	; # #
    615  f2fd		       11		      .byte.b	%00010001	; # #
    616  f2fe
    617  f2fe		       77		      .byte.b	%01110111	; ### ###
    618  f2ff		       55		      .byte.b	%01010101	; # # # #
    619  f300		       77		      .byte.b	%01110111	; ### ###
    620  f301		       55		      .byte.b	%01010101	; # # # #
    621  f302		       77		      .byte.b	%01110111	; ### ###
    622  f303
    623  f303		       77		      .byte.b	%01110111	; ### ###
    624  f304		       55		      .byte.b	%01010101	; # # # #
    625  f305		       77		      .byte.b	%01110111	; ### ###
    626  f306		       11		      .byte.b	%00010001	; # #
    627  f307		       77		      .byte.b	%01110111	; ### ###
    628  f308
    629  f308		       22		      .byte.b	%00100010	; # #
    630  f309		       55		      .byte.b	%01010101	; # # # #
    631  f30a		       77		      .byte.b	%01110111	; ### ###
    632  f30b		       55		      .byte.b	%01010101	; # # # #
    633  f30c		       55		      .byte.b	%01010101	; # # # #
    634  f30d
    635  f30d		       77		      .byte.b	%01110111	; ### ###
    636  f30e		       55		      .byte.b	%01010101	; # # # #
    637  f30f		       66		      .byte.b	%01100110	; ## ##
    638  f310		       55		      .byte.b	%01010101	; # # # #
    639  f311		       77		      .byte.b	%01110111	; ### ###
    640  f312
    641  f312		       77		      .byte.b	%01110111	; ### ###
    642  f313		       44		      .byte.b	%01000100	; # #
    643  f314		       44		      .byte.b	%01000100	; # #
    644  f315		       44		      .byte.b	%01000100	; # #
    645  f316		       77		      .byte.b	%01110111	; ### ###
    646  f317
    647  f317		       66		      .byte.b	%01100110	; ## ##
    648  f318		       55		      .byte.b	%01010101	; # # # #
    649  f319		       55		      .byte.b	%01010101	; # # # #
    650  f31a		       55		      .byte.b	%01010101	; # # # #
    651  f31b		       66		      .byte.b	%01100110	; ## ##
    652  f31c
    653  f31c		       77		      .byte.b	%01110111	; ### ###
    654  f31d		       44		      .byte.b	%01000100	; # #
    655  f31e		       77		      .byte.b	%01110111	; ### ###
    656  f31f		       44		      .byte.b	%01000100	; # #
    657  f320		       77		      .byte.b	%01110111	; ### ###
    658  f321
    659  f321		       77		      .byte.b	%01110111	; ### ###
    660  f322		       44		      .byte.b	%01000100	; # #
    661  f323		       66		      .byte.b	%01100110	; ## ##
    662  f324		       44		      .byte.b	%01000100	; # #
    663  f325		       44		      .byte.b	%01000100	; # #
    664  f326
    665  f326
    666  f326							; below is an option for digits instead of binary above
    667  f326				   DigitsHex
    668  f326		       22 22 22 22*	      .byte.b	$22,$22,$22,$22,$22
    669  f32b		       ee 22 ee 88*	      .byte.b	$EE,$22,$EE,$88,$EE
    670  f330		       ee 22 66 22*	      .byte.b	$EE,$22,$66,$22,$EE
    671  f335		       aa aa ee 22*	      .byte.b	$AA,$AA,$EE,$22,$22
    672  f33a		       ee 88 ee 22*	      .byte.b	$EE,$88,$EE,$22,$EE
    673  f33f		       ee 88 ee aa*	      .byte.b	$EE,$88,$EE,$AA,$EE
    674  f344		       ee 22 22 22*	      .byte.b	$EE,$22,$22,$22,$22
    675  f349		       ee aa ee aa*	      .byte.b	$EE,$AA,$EE,$AA,$EE
    676  f34e		       ee aa ee 22*	      .byte.b	$EE,$AA,$EE,$22,$EE
    677  f353
    678  f353				   JetSprite
    679  f353		       00		      .byte.b	#%00000000
    680  f354		       18		      .byte.b	#%00011000	;$02	       ##
    681  f355		       3c		      .byte.b	#%00111100	;$02	      ####
    682  f356		       ff		      .byte.b	#%11111111	;$02	    ########
    683  f357		       ff		      .byte.b	#%11111111	;$02	    ########
    684  f358		       ff		      .byte.b	#%11111111	;$94	    ########
    685  f359		       66		      .byte.b	#%01100110	;$02	     ##  ##
    686  f35a		       24		      .byte.b	#%00100100	;$02	      #  #
    687  f35b		       24		      .byte.b	#%00100100	;$02	      #  #
    688  f35c
    689  f35c				   JetSpriteTurn
    690  f35c		       00		      .byte.b	#%00000000
    691  f35d		       18		      .byte.b	#%00011000	;$02
    692  f35e		       3c		      .byte.b	#%00111100	;$02
    693  f35f		       7e		      .byte.b	#%01111110	;$02
    694  f360		       7e		      .byte.b	#%01111110	;$02
    695  f361		       7e		      .byte.b	#%01111110	;$94
    696  f362		       3c		      .byte.b	#%00111100	;$02
    697  f363		       24		      .byte.b	#%00100100	;$02
    698  f364		       24		      .byte.b	#%00100100	;$02
    699  f365
    700  f365				   BomberSprite
    701  f365		       00		      .byte.b	#%00000000
    702  f366		       42		      .byte.b	#%01000010	;$02
    703  f367		       5a		      .byte.b	#%01011010	;$02
    704  f368		       5a		      .byte.b	#%01011010	;$02
    705  f369		       7e		      .byte.b	#%01111110	;$40
    706  f36a		       5a		      .byte.b	#%01011010	;$02
    707  f36b		       42		      .byte.b	#%01000010	;$02
    708  f36c		       42		      .byte.b	#%01000010	;$02
    709  f36d		       42		      .byte.b	#%01000010	;$02
    710  f36e
    711  f36e				   BomberSpriteExplode
    712  f36e				   Frame0
    713  f36e		       42		      .byte.b	#%01000010	;$02
    714  f36f		       5a		      .byte.b	#%01011010	;$02
    715  f370		       5a		      .byte.b	#%01011010	;$02
    716  f371		       7e		      .byte.b	#%01111110	;$40
    717  f372		       5a		      .byte.b	#%01011010	;$02
    718  f373		       42		      .byte.b	#%01000010	;$02
    719  f374		       42		      .byte.b	#%01000010	;$02
    720  f375		       42		      .byte.b	#%01000010	;$02
    721  f376				   Frame1
    722  f376		       42		      .byte.b	#%01000010	;$02
    723  f377		       42		      .byte.b	#%01000010	;$02
    724  f378		       4a		      .byte.b	#%01001010	;$02
    725  f379		       7e		      .byte.b	#%01111110	;$40
    726  f37a		       5a		      .byte.b	#%01011010	;$02
    727  f37b		       42		      .byte.b	#%01000010	;$02
    728  f37c		       42		      .byte.b	#%01000010	;$02
    729  f37d		       42		      .byte.b	#%01000010	;$02
    730  f37e				   Frame2
    731  f37e		       42		      .byte.b	#%01000010	;$02
    732  f37f		       42		      .byte.b	#%01000010	;$02
    733  f380		       42		      .byte.b	#%01000010	;$02
    734  f381		       76		      .byte.b	#%01110110	;$40
    735  f382		       52		      .byte.b	#%01010010	;$02
    736  f383		       42		      .byte.b	#%01000010	;$02
    737  f384		       42		      .byte.b	#%01000010	;$02
    738  f385		       42		      .byte.b	#%01000010	;$02
    739  f386				   Frame3
    740  f386		       42		      .byte.b	#%01000010	;$02
    741  f387		       42		      .byte.b	#%01000010	;$02
    742  f388		       40		      .byte.b	#%01000000	;$02
    743  f389		       40		      .byte.b	#%01000000	;$40
    744  f38a		       02		      .byte.b	#%00000010	;$02
    745  f38b		       50		      .byte.b	#%01010000	;$02
    746  f38c		       42		      .byte.b	#%01000010	;$02
    747  f38d		       42		      .byte.b	#%01000010	;$02
    748  f38e				   Frame4
    749  f38e		       00		      .byte.b	#%00000000	;$02
    750  f38f		       00		      .byte.b	#%00000000	;$02
    751  f390		       02		      .byte.b	#%00000010	;$02
    752  f391		       40		      .byte.b	#%01000000	;$40
    753  f392		       00		      .byte.b	#%00000000	;$02
    754  f393		       00		      .byte.b	#%00000000	;$02
    755  f394		       42		      .byte.b	#%01000010	;$02
    756  f395		       42		      .byte.b	#%01000010	;$02
    757  f396				   Frame5
    758  f396		       00		      .byte.b	#%00000000	;$02
    759  f397		       00		      .byte.b	#%00000000	;$02
    760  f398		       00		      .byte.b	#%00000000	;$02
    761  f399		       00		      .byte.b	#%00000000	;$40
    762  f39a		       00		      .byte.b	#%00000000	;$02
    763  f39b		       00		      .byte.b	#%00000000	;$02
    764  f39c		       40		      .byte.b	#%01000000	;$02
    765  f39d		       42		      .byte.b	#%01000010	;$02
    766  f39e				   Frame6
    767  f39e		       00		      .byte.b	#%00000000	;$02
    768  f39f		       00		      .byte.b	#%00000000	;$02
    769  f3a0		       00		      .byte.b	#%00000000	;$02
    770  f3a1		       00		      .byte.b	#%00000000	;$40
    771  f3a2		       00		      .byte.b	#%00000000	;$02
    772  f3a3		       00		      .byte.b	#%00000000	;$02
    773  f3a4		       00		      .byte.b	#%00000000	;$02
    774  f3a5		       02		      .byte.b	#%00000010	;$02
    775  f3a6
    776  f3a6				   ColorFrame0
    777  f3a6		       02		      .byte.b	#$02	;
    778  f3a7		       02		      .byte.b	#$02	;
    779  f3a8		       02		      .byte.b	#$02	;
    780  f3a9		       40		      .byte.b	#$40	;
    781  f3aa		       02		      .byte.b	#$02	;
    782  f3ab		       02		      .byte.b	#$02	;
    783  f3ac		       02		      .byte.b	#$02	;
    784  f3ad		       02		      .byte.b	#$02	;
    785  f3ae				   ColorFrame1
    786  f3ae		       02		      .byte.b	#$02	;
    787  f3af		       02		      .byte.b	#$02	;
    788  f3b0		       02		      .byte.b	#$02	;
    789  f3b1		       40		      .byte.b	#$40	;
    790  f3b2		       02		      .byte.b	#$02	;
    791  f3b3		       02		      .byte.b	#$02	;
    792  f3b4		       02		      .byte.b	#$02	;
    793  f3b5		       02		      .byte.b	#$02	;
    794  f3b6				   ColorFrame2
    795  f3b6		       02		      .byte.b	#$02	;
    796  f3b7		       02		      .byte.b	#$02	;
    797  f3b8		       02		      .byte.b	#$02	;
    798  f3b9		       40		      .byte.b	#$40	;
    799  f3ba		       02		      .byte.b	#$02	;
    800  f3bb		       02		      .byte.b	#$02	;
    801  f3bc		       02		      .byte.b	#$02	;
    802  f3bd		       02		      .byte.b	#$02	;
    803  f3be				   ColorFrame3
    804  f3be		       02		      .byte.b	#$02	;
    805  f3bf		       02		      .byte.b	#$02	;
    806  f3c0		       02		      .byte.b	#$02	;
    807  f3c1		       40		      .byte.b	#$40	;
    808  f3c2		       02		      .byte.b	#$02	;
    809  f3c3		       02		      .byte.b	#$02	;
    810  f3c4		       02		      .byte.b	#$02	;
    811  f3c5		       02		      .byte.b	#$02	;
    812  f3c6				   ColorFrame4
    813  f3c6		       02		      .byte.b	#$02	;
    814  f3c7		       02		      .byte.b	#$02	;
    815  f3c8		       02		      .byte.b	#$02	;
    816  f3c9		       40		      .byte.b	#$40	;
    817  f3ca		       02		      .byte.b	#$02	;
    818  f3cb		       02		      .byte.b	#$02	;
    819  f3cc		       02		      .byte.b	#$02	;
    820  f3cd		       02		      .byte.b	#$02	;
    821  f3ce				   ColorFrame5
    822  f3ce		       02		      .byte.b	#$02	;
    823  f3cf		       02		      .byte.b	#$02	;
    824  f3d0		       02		      .byte.b	#$02	;
    825  f3d1		       40		      .byte.b	#$40	;
    826  f3d2		       02		      .byte.b	#$02	;
    827  f3d3		       02		      .byte.b	#$02	;
    828  f3d4		       02		      .byte.b	#$02	;
    829  f3d5		       02		      .byte.b	#$02	;
    830  f3d6				   ColorFrame6
    831  f3d6		       02		      .byte.b	#$02	;
    832  f3d7		       02		      .byte.b	#$02	;
    833  f3d8		       02		      .byte.b	#$02	;
    834  f3d9		       40		      .byte.b	#$40	;
    835  f3da		       02		      .byte.b	#$02	;
    836  f3db		       02		      .byte.b	#$02	;
    837  f3dc		       02		      .byte.b	#$02	;
    838  f3dd		       02		      .byte.b	#$02	;
    839  f3de
    840  f3de				   JetColor
    841  f3de		       00		      .byte.b	#$00	;
    842  f3df		       02		      .byte.b	#$02	;
    843  f3e0		       02		      .byte.b	#$02	;
    844  f3e1		       02		      .byte.b	#$02	;
    845  f3e2		       02		      .byte.b	#$02	;
    846  f3e3		       94		      .byte.b	#$94	;
    847  f3e4		       02		      .byte.b	#$02	;
    848  f3e5		       02		      .byte.b	#$02	;
    849  f3e6		       02		      .byte.b	#$02	;
    850  f3e7
    851  f3e7				   JetColorTurn
    852  f3e7		       00		      .byte.b	#$00	;
    853  f3e8		       02		      .byte.b	#$02	;
    854  f3e9		       02		      .byte.b	#$02	;
    855  f3ea		       02		      .byte.b	#$02	;
    856  f3eb		       02		      .byte.b	#$02	;
    857  f3ec		       94		      .byte.b	#$94	;
    858  f3ed		       02		      .byte.b	#$02	;
    859  f3ee		       02		      .byte.b	#$02	;
    860  f3ef		       02		      .byte.b	#$02	;
    861  f3f0
    862  f3f0				   BomberColor
    863  f3f0		       00		      .byte.b	#$00	;
    864  f3f1		       02		      .byte.b	#$02	;
    865  f3f2		       02		      .byte.b	#$02	;
    866  f3f3		       02		      .byte.b	#$02	;
    867  f3f4		       40		      .byte.b	#$40	;
    868  f3f5		       02		      .byte.b	#$02	;
    869  f3f6		       02		      .byte.b	#$02	;
    870  f3f7		       02		      .byte.b	#$02	;
    871  f3f8		       02		      .byte.b	#$02	;
    872  f3f9
    873  f3f9
    874  f3f9							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    875  f3f9							;; Pad ROM size with exactly 4KB
    876  f3f9							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    877  fffc					      org	$FFFC	; move to position
    878  fffc		       00 f0		      word.w	Reset	; write 2 bytes with program address
    879  fffe		       00 f0		      word.w	Reset	; write 2 bytes to interruption register
